/* 
**  mod_socache_redis.c -- Apache sample socache_redis module
**  [Autogenerated via ``apxs -n socache_redis -g'']
**
**  To play with this sample module first compile it into a
**  DSO file and install it into Apache's modules directory 
**  by running:
**
**    $ apxs -c -i mod_socache_redis.c
**
**  Then activate it in Apache's httpd.conf file for instance
**
**    #   httpd.conf
**    LoadModule socache_redis_module modules/mod_socache_redis.so
**    SSLSessionCacheRedisReadWriteTimeout 5
**    SSLSessionCache redis:redis.example.com:12345,redis2.example.com:12345
**
**  Then after restarting Apache via
**
**    $ apachectl restart
**
*/ 

#include "httpd.h"
#include "http_config.h"

#include "apr.h"
#include "apr_version.h"

/* #ifdef HAVE_APU_MEMCACHE */

#include "ap_socache.h"
#include "ap_mpm.h"
#include "http_log.h"
#include "apr_redis.h"

#include <stdio.h>
#include <string.h>
#include <errno.h>

#ifdef APLOG_USE_MODULE
APLOG_USE_MODULE(socache_redis);
#endif 

#define DEFAULT_SESSION_TIMEOUT   300
#define DEFAULT_READWRITE_TIMEOUT 5

module AP_MODULE_DECLARE_DATA socache_redis_module;

struct ap_socache_instance_t {
    const char *servers;
    apr_redis_t *mc;
    const char *tag;
    apr_size_t taglen; /* strlen(tag) + 1 */
};

typedef struct socache_redis_readwritetimeout_config{
    apr_uint32_t readwrite_timeout;
} socache_redis_readwritetimeout_config_t;

static void* create_socache_redis_config(apr_pool_t* p, server_rec* s)
{
    socache_redis_readwritetimeout_config_t* conf = apr_palloc(p, sizeof(socache_redis_readwritetimeout_config_t));
    conf->readwrite_timeout = DEFAULT_READWRITE_TIMEOUT;
    return conf;
}

static const char* socache_redis_set_readwritetimeout(cmd_parms* cmd, void* dummy, const char* arg)
{
    char *str;
    socache_redis_readwritetimeout_config_t* conf = ap_get_module_config(cmd->server->module_config, &socache_redis_module);
    if (conf != NULL && (str = ap_getword_conf(cmd->pool, &arg))) {
        apr_uint32_t value;
        char *endp;
        errno = 0;
        value = (apr_uint32_t) strtoul(str, &endp, 10);
        if (errno == 0) {
            conf->readwrite_timeout = value;
        } else {
            return strerror(errno);
        }
    } else {
        return "SSLSessionCacheRedisReadWriteTimeout requires integer value";
    }
    return NULL;
}

static const char *socache_mc_create(ap_socache_instance_t **context,
                                     const char *arg,
                                     apr_pool_t *tmp, apr_pool_t *p)
{
    ap_socache_instance_t *ctx;

    *context = ctx = apr_palloc(p, sizeof *ctx);

    if (!arg || !*arg) {
        return "List of server names required to create redis socache.";
    }

    ctx->servers = apr_pstrdup(p, arg);

    return NULL;
}

static apr_status_t socache_mc_init(ap_socache_instance_t *ctx,
                                    const char *namespace,
                                    const struct ap_socache_hints *hints,
                                    server_rec *s, apr_pool_t *p)
{
    apr_status_t rv;
    int thread_limit = 0;
    apr_uint16_t nservers = 0;
    char *cache_config;
    char *split;
    char *tok;

    socache_redis_readwritetimeout_config_t* config = ap_get_module_config(s->module_config, &socache_redis_module);
    apr_uint32_t readwrite_timeout = DEFAULT_READWRITE_TIMEOUT;
    if (config != NULL) {
        readwrite_timeout = config->readwrite_timeout;
    }

    ap_mpm_query(AP_MPMQ_HARD_LIMIT_THREADS, &thread_limit);

    /* Find all the servers in the first run to get a total count */
    cache_config = apr_pstrdup(p, ctx->servers);
    split = apr_strtok(cache_config, ",", &tok);
    while (split) {
        nservers++;
        split = apr_strtok(NULL,",", &tok);
    }

    rv = apr_redis_create(p, nservers, 0, &ctx->mc);
    if (rv != APR_SUCCESS) {
        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s, APLOGNO(00785)
                     "Failed to create Redis Object of '%d' size.",
                     nservers);
        return rv;
    }

    /* Now add each server to the redis */
    cache_config = apr_pstrdup(p, ctx->servers);
    split = apr_strtok(cache_config, ",", &tok);
    while (split) {
        apr_redis_server_t *st;
        char *host_str;
        char *scope_id;
        apr_port_t port;

        rv = apr_parse_addr_port(&host_str, &scope_id, &port, split, p);
        if (rv != APR_SUCCESS) {
            ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s, APLOGNO(00786)
                         "Failed to Parse redis Server: '%s'", split);
            return rv;
        }

        if (host_str == NULL) {
            ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s, APLOGNO(00787)
                         "Failed to Parse Server, "
                         "no hostname specified: '%s'", split);
            return APR_EINVAL;
        }

        if (port == 0) {
            port = MC_DEFAULT_SERVER_PORT;
        }

        rv = apr_redis_server_create(p,
                                     host_str, port,
                                     MC_DEFAULT_SERVER_MIN,
                                     MC_DEFAULT_SERVER_SMAX,
                                     thread_limit,
                                     MC_DEFAULT_SERVER_TTL,
                                     readwrite_timeout,
                                     &st);
        if (rv != APR_SUCCESS) {
            ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s, APLOGNO(00788)
                         "Failed to Create redis Server: %s:%d",
                         host_str, port);
            return rv;
        }

        rv = apr_redis_add_server(ctx->mc, st);
        if (rv != APR_SUCCESS) {
            ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s, APLOGNO(00789)
                         "Failed to Add redis Server: %s:%d",
                         host_str, port);
            return rv;
        }

        split = apr_strtok(NULL,",", &tok);
    }

    ctx->tag = apr_pstrcat(p, namespace, ":", NULL);
    ctx->taglen = strlen(ctx->tag) + 1;

    /* socache API constraint: */
    AP_DEBUG_ASSERT(ctx->taglen <= 16);

    return APR_SUCCESS;
}

static void socache_mc_destroy(ap_socache_instance_t *context, server_rec *s)
{
    /* noop. */
}

/* Converts (binary) id into a key prefixed by the predetermined
 * namespace tag; writes output to key buffer.  Returns non-zero if
 * the id won't fit in the key buffer. */
static int socache_mc_id2key(ap_socache_instance_t *ctx,
                             const unsigned char *id, unsigned int idlen,
                             char *key, apr_size_t keylen)
{
    char *cp;

    if (idlen * 2 + ctx->taglen >= keylen)
        return 1;

    cp = apr_cpystrn(key, ctx->tag, ctx->taglen);
    ap_bin2hex(id, idlen, cp);

    return 0;
}

static apr_status_t socache_mc_store(ap_socache_instance_t *ctx, server_rec *s,
                                     const unsigned char *id, unsigned int idlen,
                                     apr_time_t expiry,
                                     unsigned char *ucaData, unsigned int nData,
                                     apr_pool_t *p)
{
    char buf[MC_KEY_LEN];
    apr_status_t rv;
    apr_uint32_t timeout;

    if (socache_mc_id2key(ctx, id, idlen, buf, sizeof(buf))) {
        return APR_EINVAL;
    }
    timeout = apr_time_sec(expiry - apr_time_now());
    if (timeout <= 0) {
        timeout = DEFAULT_SESSION_TIMEOUT;
        ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, APR_SUCCESS, s, "set default timeout:%u", timeout);
    }

    /* In APR-util - unclear what 'timeout' is, as it was not implemented */
    rv = apr_redis_setex(ctx->mc, buf, (char*)ucaData, nData, timeout, 0);

    if (rv != APR_SUCCESS) {
        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s, APLOGNO(00790)
                     "scache_mc: error setting key '%s' "
                     "with %d bytes of data", buf, nData);
        return rv;
    }

    return APR_SUCCESS;
}

static apr_status_t socache_mc_retrieve(ap_socache_instance_t *ctx, server_rec *s,
                                        const unsigned char *id, unsigned int idlen,
                                        unsigned char *dest, unsigned int *destlen,
                                        apr_pool_t *p)
{
    apr_size_t data_len;
    char buf[MC_KEY_LEN], *data;
    apr_status_t rv;

    if (socache_mc_id2key(ctx, id, idlen, buf, sizeof buf)) {
        return APR_EINVAL;
    }

    /* ### this could do with a subpool, but _getp looks like it will
     * eat memory like it's going out of fashion anyway. */

    rv = apr_redis_getp(ctx->mc, p, buf, &data, &data_len, NULL);
    if (rv) {
        if (rv != APR_NOTFOUND) {
            ap_log_error(APLOG_MARK, APLOG_ERR, rv, s, APLOGNO(00791)
                         "scache_mc: 'retrieve' FAIL");
        }
        return rv;
    }
    else if (data_len > *destlen) {
        ap_log_error(APLOG_MARK, APLOG_ERR, rv, s, APLOGNO(00792)
                     "scache_mc: 'retrieve' OVERFLOW");
        return APR_ENOMEM;
    }

    memcpy(dest, data, data_len);
    *destlen = data_len;

    return APR_SUCCESS;
}

static apr_status_t socache_mc_remove(ap_socache_instance_t *ctx, server_rec *s,
                                      const unsigned char *id,
                                      unsigned int idlen, apr_pool_t *p)
{
    char buf[MC_KEY_LEN];
    apr_status_t rv;

    if (socache_mc_id2key(ctx, id, idlen, buf, sizeof buf)) {
        return APR_EINVAL;
    }

    rv = apr_redis_delete(ctx->mc, buf, 0);

    if (rv != APR_SUCCESS) {
        ap_log_error(APLOG_MARK, APLOG_DEBUG, rv, s, APLOGNO(00793)
                     "scache_mc: error deleting key '%s' ",
                     buf);
    }

    return rv;
}

static void socache_mc_status(ap_socache_instance_t *ctx, request_rec *r, int flags)
{
    /* TODO: Make a mod_status handler. meh. */
}

static apr_status_t socache_mc_iterate(ap_socache_instance_t *instance,
                                       server_rec *s, void *userctx,
                                       ap_socache_iterator_t *iterator,
                                       apr_pool_t *pool)
{
    return APR_ENOTIMPL;
}

static const ap_socache_provider_t socache_mc = {
    "redis",
    0,
    socache_mc_create,
    socache_mc_init,
    socache_mc_destroy,
    socache_mc_store,
    socache_mc_retrieve,
    socache_mc_remove,
    socache_mc_status,
    socache_mc_iterate,
};

//#endif /* HAVE_APU_MEMCACHE */

static void register_hooks(apr_pool_t *p)
{
    ap_register_provider(p, AP_SOCACHE_PROVIDER_GROUP, "redis",
                         AP_SOCACHE_PROVIDER_VERSION,
                         &socache_mc);
}

static const command_rec mod_socache_redis_cmds[] =
{
    AP_INIT_TAKE1(
                  "SSLSessionCacheRedisReadWriteTimeout",
                  socache_redis_set_readwritetimeout,
                  NULL,
                  ACCESS_CONF | RSRC_CONF,
                  "SSLSessionCacheRedisReadWriteTimeout [seconds]."
                  ),
    {NULL}
};

/* Dispatch list for API hooks */
module AP_MODULE_DECLARE_DATA socache_redis_module = {
    STANDARD20_MODULE_STUFF, 
    NULL,                        /* create per-dir    config structures */
    NULL,                        /* merge  per-dir    config structures */
    create_socache_redis_config, /* create per-server config structures */
    NULL,                        /* merge  per-server config structures */
    mod_socache_redis_cmds,      /* table of config file commands       */
    register_hooks               /* register hooks                      */
};

